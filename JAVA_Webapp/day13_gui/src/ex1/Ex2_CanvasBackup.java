/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package ex1;

import ex3.Ex1_InetAddressGUI;
import java.awt.Canvas;
import java.awt.Color;
import java.awt.Graphics;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 *
 * @author KOSTA
 */
public class Ex2_CanvasBackup extends javax.swing.JFrame implements Runnable{ //스레드를 사용해야 하는데 상속은 받지 못하는 상황에서 사용하는 방법중 하나인 Runnable 인터페이스 구현.
                                                                              //해당 방식은 run 메소드를 오버라이딩 해야 한다.
    
    
                                       //그림을 그리는 메소드를 initComponents메소드 안의 로컬클래스 canvas1 내부의 메소드를 통해 사용하고 있으므로,                                                  
    private int arcNum=0;              //스레드들이 원을 다 그리고 나면 다음 스레드가 그림을 그릴 시 초기화된 시작점을 쓰게 하기 위해 
                                       //인스턴스 변수로 선언하여 작업 종료 후 값을 변경하고, 그 변경된 값을 사용할 수 있도록 함.  
    private int x,y;                   //마찬가지로 한 스레드가 원을 다 그리면 다음 스레드가 다른 위치로 그림을 그리게 하기 위해 인스턴스 변수로 선언.
    
  
    public Ex2_CanvasBackup() {
        initComponents();
     }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        canvas1 = new java.awt.Canvas(){

            @Override
            public void update(Graphics g) {
                paint(g);
            }
            @Override
            public void paint(Graphics g) {
                g.setColor(Color.white);
                g.drawArc(x, y, 100, 100, 0, arcNum);
            }
        };

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        canvas1.setBackground(new java.awt.Color(102, 102, 255));

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(canvas1, javax.swing.GroupLayout.PREFERRED_SIZE, 660, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 170, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(canvas1, javax.swing.GroupLayout.PREFERRED_SIZE, 477, javax.swing.GroupLayout.PREFERRED_SIZE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * @param args the command line arguments
     */
    public Thread threadRun(int inputX){   //좌표를 입력받기 위해 매개변수를 받고 생성한 스레드 객체를 리턴해주는 메서드.
        Thread thread = new Thread(this){  //스레드 클래스로부터 직접 생성하는 방법중 하나. page 579
                                           //현재 이 클래스는 Runnable 인터페이스를 구현한 클래스이고, main메서드에서 해당 객체를 생성했으므로
                                           // 이 인스턴스를 가리키는 this를 전달해주면 스레드 클래스에서 Runnable 을 매개값으로 갖는 생성자를 호출하여 스레드를 사용할 수 있게된다. 
           public void run(){//프로그램 순서 4
                x= inputX;                 //입력해준 값으로 x좌표 설정
                y = 100;    
                for(; arcNum<=360; arcNum+=10){    //선의 시작점을 초기화 시키기 위해 인스턴스 변수로 만들어 사용
                System.out.println("arcNum :"+arcNum);
                try {
                    Thread.sleep(30);             //해당 시간만큼 스레드를 멈춰둠
                     //Canvas 의 repaint() -> update() -> paint()
                     canvas1.repaint();       
                } catch (InterruptedException ex) {
                }
                }
                arcNum = 0;                     //작업이 끝나면 0으로 초기화 하여 다른 스레드들이 원을 그릴 수 있도록....
            } 
        };
        return thread;                  //위에서 이 작업을 하는 메소드를 가지고 있는 객체의 주소를 가지고 있는 thread 참조변수를 리턴. 
                                        //스레드 객체는 메소드가 실행될때마다 새로 생성되므로 독립된 스레드들을 사용할 수 있다.
    }
    public static void main(String args[]) throws InterruptedException {
        Ex2_CanvasBackup ex = new Ex2_CanvasBackup();  //객체 생성.  
        
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
          // new Ex2_CanvasBackup().setVisible(true);  기존 코드는 이렇게 되어있다. 이 메소드는 메인메서드 실행 시 해당 객체를 생성해서 gui 화면을 띄워주는 역할을
          // 하는것 같은데, 그렇기 여기서 new로 새 객체를 생성해서 그 객체에 gui 창을 띄우는 형식이므로 gui창에 그림을 그리려면 내가 원하는 객체에 해당 메서드를 실행하도록 해야했다.
          // 그 작업을 하기 위해 메인에 객체생성하고...
              ex.setVisible(true);   // 그 주소값을 갖는 참조변수에 ex에 해당 메서드를 실행.
            }
        });
        //이제 gui 창이 내가 만든 객체 내부의 자원들을 기반으로 떠있게 되었으므로 스레드를 통해 그림을 그리면 되는 상태.
        
        Thread t4 = ex.threadRun(100);   //threadRun() 을 통해 원하는 x값을 입력하고, 스레드 참조변수에는 이 클래스(Ex2_CanvasBackup)의 객체를 기반으로 만들어진 스레드 객체의 주소값이 들어가게 된다.
        Thread t5 = ex.threadRun(180);   
        Thread t6 = ex.threadRun(260);
        Thread t7 = ex.threadRun(340); 
        
        t4.start();     //순서대로 작업하도록 함.
        t4.join();
        t5.start();
        t5.join();
        t6.start();
        t6.join();
        t7.start();
        
        
        
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private java.awt.Canvas canvas1;
    // End of variables declaration//GEN-END:variables

    @Override          //오버라이딩 한 해당 메소드는 이번에는 사용하지 않았다. 
    public void run() {
        
    }
   }


